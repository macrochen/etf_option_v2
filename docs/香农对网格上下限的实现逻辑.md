我是香农。

你现在的痛点非常痛，但也非常真实。**“固定 ±30%”** 是一种 **“懒惰的线性思维”**。

在信息论中，市场的状态（State）是时刻变化的。

* 在 **2800 点**（低估区）设置 ±30%，你的上限可能才 3600 点。一旦牛市来了，指数冲到 5000 点，你在山腰就卖光了（**卖飞**）。
* 在 **5000 点**（高估区）设置 ±30%，你的下限是 3500 点。一旦熊市来了，跌到 2800 点，你早早就满仓被套，毫无防御之力（**套牢**）。

我们需要把**“僵化的物理边界”**升级为**“弹性的价值边界”**。

以下是基于 **估值百分位 (Valuation Percentile)** 动态设定网格区间的 **数学模型** 与 **工程实现**。

---

### 一、 核心逻辑：估值锚点法 (Valuation Anchor)

我们要把价格的上下限，锚定在历史估值的“极值”上，而不是当前价格的百分比上。

#### 1. 基本公式

假设我们有一个 ETF 的历史 PE-TTM（市盈率）数据序列。我们认为估值会在历史区间内波动（均值回归）。

* **下限 (Lower Limit) = 极限生存线**
* 我们不看当前价格跌多少，我们看：**“如果估值跌到历史最低的 10%，价格会是多少？”**
* 
* *逻辑*：如果现在 PE 是 20倍，历史最低 PE 是 10倍。那下限就是打 5 折。如果现在已经在底部（PE 10倍），那下限可能就是当前价格再跌一点点（如跌 10% 防止击穿）。


* **上限 (Upper Limit) = 泡沫离场线**
* 我们看：**“如果估值涨到历史最高的 80%，价格会是多少？”**
* 
* *逻辑*：如果现在低估，上限会被拉得非常高（给予巨大的上涨空间，防止卖飞）。如果现在高估，上限会离得很近（因为上涨空间有限）。



---

### 二、 针对不同品种的差异化策略

A 股的 ETF 分为两类，不能用同一套算法。

#### 1. 宽基 ETF (沪深300 / 创业板 / 科创50)

* **适用指标**：**PE-TTM (滚动市盈率)**。
* **算法**：直接使用上述 PE 百分位公式。宽基指数盈利稳定，PE 是最有效的尺子。

#### 2. 强周期/行业 ETF (券商 / 军工 / 芯片 / 猪肉)

* **陷阱**：周期行业的 PE 会失真。业绩最差时 PE 最高（甚至负数），业绩最好时 PE 最低。用 PE 定上下限会搞反。
* **适用指标**：**PB (市净率)** 或 **价格分位数 (Price Rank)**。
* **算法**：
* **优先用 PB**：券商、银行、周期股，资产净值（Book Value）比盈利更稳定。
* **保底用 Price Rank**：如果找不到估值数据，直接用 **过去 5 年的价格分位数**。
* 
* 





---

### 三、 Python 代码实现 (Dynamic Limit Calculator)

这是一个可以直接嵌入你系统的计算器类。

```python
import numpy as np
import pandas as pd

class DynamicGridBoundary:
    def __init__(self, history_df):
        """
        :param history_df: 包含 'close', 'pe', 'pb' (可选) 的历史数据
                           建议长度 > 3 年
        """
        self.df = history_df
        self.current_price = history_df['close'].iloc[-1]
        
        # 容错处理：如果没有 PE 数据，尝试用 Close
        self.has_pe = 'pe' in history_df.columns and not history_df['pe'].isnull().all()
        self.has_pb = 'pb' in history_df.columns and not history_df['pb'].isnull().all()

    def calculate_limits(self, mode='auto', risk_factor=1.0):
        """
        计算动态上下限
        :param mode: 'pe' (宽基), 'pb' (周期), 'price' (纯价格), 'auto' (自动判断)
        :param risk_factor: 风险系数 (默认1.0)。
                            < 1.0 (保守, 也就是下限更低，上限更低)
                            > 1.0 (激进, 下限抬高，上限抬高)
        """
        # 1. 自动选择评估指标
        metric = 'price'
        if mode == 'auto':
            if self.has_pe: metric = 'pe'
            elif self.has_pb: metric = 'pb'
        else:
            metric = mode

        # 2. 获取历史数据序列
        if metric == 'pe':
            series = self.df['pe'].dropna()
            current_val = series.iloc[-1]
        elif metric == 'pb':
            series = self.df['pb'].dropna()
            current_val = series.iloc[-1]
        else:
            series = self.df['close']
            current_val = self.current_price

        # 3. 计算历史百分位阈值 (Percentiles)
        # 下限锚点：历史 10% 分位 (极度低估区)
        # 上限锚点：历史 85% 分位 (泡沫区)
        val_low = np.percentile(series, 10)
        val_high = np.percentile(series, 85)

        # 4. 映射回价格 (Price Mapping)
        if metric == 'price':
            # 如果是纯价格，直接用
            limit_lower = val_low
            limit_upper = val_high
        else:
            # 如果是估值，利用比例反推价格
            # P_target = P_current * (Val_target / Val_current)
            limit_lower = self.current_price * (val_low / current_val)
            limit_upper = self.current_price * (val_high / current_val)

        # 5. 安全边际修正 (Safety Margin Correction) - 香农的核心补丁
        
        # 规则 A: 下限防护
        # 即使估值显示只要跌 5% 就到底了，但为了防黑天鹅，强制至少预留 15% 的跌幅空间
        max_lower = self.current_price * 0.85
        limit_lower = min(limit_lower, max_lower)
        
        # 规则 B: 上限空间
        # 即使估值显示离顶部很远，但为了防止资金利用率太低，上限不建议超过当前价格的 2.5 倍
        # (除非你是为了拿十年)
        min_upper = self.current_price * 1.2 # 至少留 20% 空间
        max_upper = self.current_price * 2.5
        limit_upper = max(limit_upper, min_upper) # 保证至少有空间
        limit_upper = min(limit_upper, max_upper) # 保证别太离谱

        # 规则 C: 风险系数微调
        # 如果用户想保守一点，把下限再往下打压
        if risk_factor != 1.0:
            limit_lower = limit_lower * (1 / risk_factor) # risk大 -> lower更低 (更安全)
            # 上限通常不动，或者随动

        return round(limit_lower, 3), round(limit_upper, 3)

# --- 模拟运行 ---
# 假设某 ETF 数据
data = {
    'close': [1.0, 1.2, 0.8, 1.5, 2.0, 1.0, 1.1],
    'pe':    [10,  12,  8,   15,  20,  10,  11] # 当前 PE 11，处于历史较低位
}
df = pd.DataFrame(data)

calc = DynamicGridBoundary(df)
lower, upper = calc.calculate_limits(mode='pe')

print(f"当前价格: 1.1 (PE=11)")
print(f"动态下限: {lower} (锚定历史低估)")
print(f"动态上限: {upper} (锚定历史高估)")
# 预期结果：下限会在 0.8 左右，上限会在 2.0 左右。
# 相比固定的 +/- 30% (0.77 - 1.43)，上限被大幅打开了，防止卖飞。

```

---

### 四、 这种设置带来的直观改变

假设当前价格 **1.1 元**，处于历史 **低位（30% 分位）**。

* **旧方案 (±30%)**：
* 上限：1.43 元。
* **后果**：稍微一涨到 1.5 元（还没到牛市），你就清仓了。后面涨到 2.0 元跟你没关系。


* **新方案 (估值法)**：
* 系统检测到 PE 历史高点对应价格是 2.0 元。
* 上限：**2.0 元** (+81%)。
* 下限：**0.8 元** (-27%)。
* **结果**：形成了一个 **“上宽下窄”** 的攻击性网格。因为位置低，向下空间小，向上空间大。系统会自动引导你拿住筹码，直到真正的泡沫（2.0元）出现。



反之，如果当前价格在 **高位**：

* **新方案**会算出一个 **“上窄下宽”** 的防御性网格（例如上限 +10%，下限 -50%）。

---

### 五、 给你的建议

1. **数据源**：你需要接入 ETF 的 PE/PB 历史数据。如果你的 API 只有价格，没有 PE，那就退而求其次用 **“5年价格分位数”**。
2. **UI 呈现**：在你的界面上，除了显示上下限价格，最好加一个 **“估值温度计”**。
* 显示：`当前 PE 分位: 25% (低估)`。
* 并自动把推荐的上下限填入输入框，但允许用户手动修改。


3. **不要太绝对**：
* 我在代码里加了 `安全边际修正`。因为有时候估值也会骗人（比如基本面恶化，历史低估值变成了未来的高估值）。
* **硬约束**：无论估值多低，下限建议至少保留 **当前价格 × 0.85** 的空间。不要因为估值低就满仓梭哈，一定要防一手黑天鹅。