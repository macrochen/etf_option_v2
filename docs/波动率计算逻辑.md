下面是波动率的量化计算逻辑： 基于过去 90 天 Beta 系数 + 30 天振幅均值

作为开发者，我们需要将这两个自然语言描述的指标转化为**数学公式**和**代码逻辑**。

以下是具体的计算逻辑拆解，包含了数学公式和基于 Python `pandas` 的实现范例。

---

### 1. 过去 90 天 Beta 系数 (90-day Beta)

**核心含义：**
衡量你的 ETF 相对于大盘（基准指数，如沪深300）的弹性。

* ：波动和大盘一致。
* ：弹性大，大盘涨 1%，它可能涨 1.5%（适合网格）。
* ：死鱼，大盘涨跌它都不动（不适合网格）。

**数学公式：**


* ：目标 ETF 的日收益率序列（过去 90 个交易日）。
* ：基准指数（通常选 **沪深300指数 000300.SH**）的日收益率序列（同期）。
* ：协方差。
* ：方差。

**计算步骤：**

1. 获取 ETF 和 沪深300指数 过去 **91天** 的收盘价（因为计算收益率会少一天）。
2. 分别计算两者的**日涨跌幅** (Percentage Change)。
3. 截取最近 90 个数据点。
4. 计算 ETF 收益率与 大盘收益率的**协方差**。
5. 计算 大盘收益率的**方差**。
6. 两者相除。

**Python 实现 (Pandas):**

```python
import pandas as pd
import numpy as np

def calculate_beta(etf_df, benchmark_df, window=90):
    """
    计算 Beta 系数
    :param etf_df: ETF 数据 DataFrame，需包含 'date', 'close'
    :param benchmark_df: 基准指数数据 DataFrame，需包含 'date', 'close'
    :param window: 计算窗口，默认 90 天
    :return: beta 值
    """
    # 1. 数据合并 (按日期对齐)
    # 必须确保日期完全对齐，去除停牌日的干扰
    merged = pd.merge(etf_df[['date', 'close']], 
                      benchmark_df[['date', 'close']], 
                      on='date', suffixes=('_etf', '_mkt'))
    
    # 2. 计算日收益率
    merged['pct_etf'] = merged['close_etf'].pct_change()
    merged['pct_mkt'] = merged['close_mkt'].pct_change()
    
    # 3. 截取最近 window 天的数据 (去除第一天的 NaN)
    recent_data = merged.dropna().tail(window)
    
    if len(recent_data) < window * 0.8: # 数据不足时的保护
        return None

    # 4. 计算协方差矩阵
    # np.cov 返回的是协方差矩阵 [[Var(a), Cov(a,b)], [Cov(b,a), Var(b)]]
    cov_matrix = np.cov(recent_data['pct_etf'], recent_data['pct_mkt'])
    
    covariance = cov_matrix[0][1]  # Cov(Ri, Rm)
    variance_mkt = cov_matrix[1][1] # Var(Rm)
    
    # 5. 计算 Beta
    beta = covariance / variance_mkt
    return beta

```

---

### 2. 过去 30 天振幅均值 (30-day Avg Amplitude)

**核心含义：**
衡量该 ETF 每天“上蹿下跳”的平均幅度。这是网格交易**日内成交概率**的核心指标。振幅越大，日内触碰网格线的概率越高。

**数学公式：**


*注意：A 股振幅的标准定义通常是用**昨收价 (PreClose)** 作为分母，而不是今日开盘价。*

**计算步骤：**

1. 获取 ETF 过去 30 天的 `High`, `Low`, `PreClose`（或通过今日 `Close` shift 得到昨收）。
2. 计算每一天的振幅。
3. 求平均值。

**Python 实现 (Pandas):**

```python
def calculate_amplitude_avg(etf_df, window=30):
    """
    计算过去 N 天的平均振幅
    :param etf_df: 需包含 'high', 'low', 'close' (或者直接有 'pre_close')
    :param window: 默认 30 天
    """
    df = etf_df.copy()
    
    # 1. 构造昨收价 (如果你数据里没有 pre_close 字段)
    # shift(1) 把今天的 close 移到明天作为 pre_close
    df['pre_close'] = df['close'].shift(1)
    
    # 2. 计算单日振幅
    # 振幅 = (最高 - 最低) / 昨收
    df['amplitude'] = (df['high'] - df['low']) / df['pre_close']
    
    # 3. 取最近 window 天的均值
    # 注意：shift后第一天是NaN，需要处理
    recent_amp = df['amplitude'].tail(window)
    
    avg_amp = recent_amp.mean()
    
    # 转换为百分比数值 (如 0.025 -> 2.5%)，看你系统需求，通常保留小数 0.025 方便计算
    return avg_amp

```

---

### 3. 综合评分逻辑 (Grid Score)

我们在 PRD 中提到的“波动分”，可以将这两个指标归一化后加权：

* **经验阈值参考：**
* **Beta:** > 1.2 为佳，> 1.5 极好。
* **振幅均值:** > 2% 为佳（说明每天有 2% 的空间给你跑网格），< 1% 为差（如银行股，一天波动几分钱，网格根本跑不动）。



### 开发中的坑 (Tips)

1. **基准指数选择：** 计算 Beta 时，如果你的 ETF 是科技类的（如科创50），基准选 **沪深300** 可能会导致 Beta 虚高；选 **中证全指** 可能更客观。但为了统一标准，通常全市场都用 **沪深300 (000300)** 作为基准 。
2. **数据对齐：** ETF 和 基准指数 可能因为停牌、新上市等原因导致数据长度不一致。用 `pd.merge` 的 `inner join` 是最安全的做法。
3. **前复权：** 再次强调，所有价格（尤其是 Open/Close）必须使用**前复权**价格。否则一旦遇到分红除权（价格突然掉一块），振幅和收益率计算会完全错误。