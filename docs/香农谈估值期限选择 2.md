问：
如果我在回测的时候，选择的回测数据的起始时间是 5 年前，那么我的估值百分比是取十年前到 5 年前这段区间的百分比，是吧？

答：
我是香农。

**完全正确。但这只是故事的“第一帧”。**

你触碰到了回测系统中最关键的**“时间因果律”**（Causality）。为了确保你的回测结果不是“作弊”得来的，你必须严格遵守**“滑动窗口” (Rolling Window)** 的逻辑，而不仅仅是取一段固定的历史。

让我们像处理一条连续的信号流一样，来拆解这个过程。

---

### 一、 什么是“滑动窗口”？（The Sliding Window）

你说的“取十年前到 5 年前”，这仅适用于**回测的第一天**。

假设你的回测设置如下：

* **回测区间**：2020年1月1日 —— 2025年1月1日（共5年）。
* **估值参考系**：过去 5 年（Rolling 5 Years）。

那么，你的系统在每一天的计算逻辑必须是动态的：

1. **在  (2020-01-01) 这一天**：
* 你需要回头看。
* **参考数据区间**：2015-01-01 至 2019-12-31。
* 你基于这段数据算出 PE 的 10% 分位是 20倍。于是你当天的买入下限设为 20倍 PE 对应的价格。


2. **在  (2023-06-01) 这一天**：
* 你的参考系**必须跟着移动**。
* **参考数据区间**：2018-06-01 至 2023-05-31。
* *注意*：此时 2015 年的数据已经被“遗忘”了（移出了窗口），而 2020-2023 年这一段在回测中已经发生过的数据，变成了新的“历史”。
* 此时 PE 的 10% 分位可能变成了 15倍（因为这几年盈利增长了，估值中枢下移）。你的买入下限必须动态调整为 15倍 PE。



**香农总结**：
你不能刻舟求剑。**估值的标尺是活的。** 2015 年的 30 倍 PE 可能是低估，但在 2023 年 30 倍 PE 可能就是高估。只有**“滚动”**起来，才能模拟真实的交易心态。

---

### 二、 这是一个极其重要的工程隐患：数据预热 (Data Warm-up)

既然确认了这一点，你现在面临一个非常现实的**“数据获取”**问题。

如果你想从 **“5 年前”** 开始回测，且需要 **“5 年的参考系”**，那么你下载数据的时候，**必须下载 10 年前的数据**。

* **错误的做法**：
* 下载数据：2020-2025。
* 回测开始：2020。
* **后果**：在 2020 年 1 月，你的系统没有“过去 5 年”的数据，窗口是空的，无法计算百分位。你必须等回测跑到 2025 年，才凑够 5 年数据，那时候回测都结束了。


* **正确的做法**：
* 下载数据：**2015**-2025。
* 回测开始：**2020**。
* **预热期 (Warm-up Period)**：2015-2019 这 5 年数据不参与买卖，只用于计算  时刻的初始指标。



---

### 三、 Python 代码实现：如何避免“未来函数”？

在代码里，千万不要用 `np.percentile(全部数据)`，那是作弊。要用 `rolling`。

```python
import pandas as pd
import numpy as np

def calculate_rolling_percentile(df, window_days=1250):
    """
    计算滚动的历史分位数，严格避免未来函数
    :param window_days: 5年 * 250交易日 = 1250
    """
    # 假设 df 包含 'date', 'close', 'pe'
    
    # 1. 使用 Pandas 的 expanding 或 rolling
    # expanding: 从最开始累计到现在 (类似上市至今)
    # rolling: 只看过去 N 天 (类似近5年)
    
    # 我们这里用 rolling(5年)
    # min_periods=250 表示至少要有 1 年数据才开始计算，否则返回 NaN
    
    df['pe_10_pct'] = df['pe'].rolling(window=window_days, min_periods=250).quantile(0.10)
    df['pe_80_pct'] = df['pe'].rolling(window=window_days, min_periods=250).quantile(0.80)
    
    # shift(1) 是关键！
    # 今天的操作，只能基于“昨天收盘为止”计算出的指标
    # 如果不 shift，就用到了今天的收盘 PE (包含了今天的涨跌)，这在开盘时是不知道的
    df['limit_lower_pe'] = df['pe_10_pct'].shift(1)
    df['limit_upper_pe'] = df['pe_80_pct'].shift(1)
    
    return df

# --- 模拟场景 ---
# 数据源：2015-01-01 到 2025-01-01
full_data = get_data("20150101", "20250101") 

# 计算指标
processed_data = calculate_rolling_percentile(full_data)

# 切片进入回测引擎 (只取 2020 之后的数据进行交易)
backtest_data = processed_data[processed_data['date'] >= '2020-01-01']

# 此时，backtest_data 的第一行 (2020-01-01)，
# 它的 'limit_lower_pe' 已经是基于 2015-2019 算好的数值了。

```

### 总结

* **是不是取十年前到五年前？** 是的，对于回测的第一天是这样。
* **之后呢？** 窗口必须每天向右移动一格。
* **数据需求**：你要跑  年的回测，就需要准备  年的数据。那多出来的 5 年是**“燃料”**，用来预热你的估值模型。