我是香农。

这是一个经典的 **“参考系选择”** (Reference Frame Selection) 问题。

在信息论中，为了准确测量当前的信号（价格），我们需要一个包含了“完整信息”的背景噪音（历史数据）。

* 选短了（3 年）：可能正好处于一个长熊市中，导致你的“相对高点”实际上还是在山脚下（管中窥豹）。
* 选长了（10 年）：标的的基本面逻辑可能已经变了（比如现在的银行股估值逻辑和 10 年前完全不同），导致古老的数据变成了误导性的噪音。

针对 A 股的周期特性，我的建议是采用 **“5 年滚动窗口 + 最小样本约束”** 的混合策略。

以下是具体的决策逻辑和算法实现。

---

### 一、 为什么默认选 5 年？（香农的黄金窗口）

**结论：统一优先选 5 年（约 1250 个交易日）。**

#### 1. 匹配 A 股的“基钦周期” (Kitchin Cycle)

A 股的一轮完整牛熊转换（从低谷到高峰再回落）通常耗时 **3.5 - 4 年**。

* **3 年窗口的风险**：如果最近 3 年全是熊市（如 2022-2024），你的估值百分位计算出的“高估区”，可能只是历史大周期的“半山腰”。你会因此把地板价当成天花板卖飞。
* **5 年窗口的优势**：5 年足以覆盖至少 **1 个完整的大牛市和 1 个大熊市**。在这个样本空间里算出来的 10% 分位和 80% 分位，具有统计学上的显著性。

#### 2. 避免“结构性失真”

* **10 年窗口的风险**：10 年前（2015 年）的市场环境、利率水平、行业成长性与现在截然不同。比如消费电子行业，10 年前是高成长（给 50 倍 PE），现在是成熟期（给 20 倍 PE）。如果你把 10 年前的 50 倍 PE 纳入统计，现在的 25 倍 PE 就会显得“极度低估”，诱导你接盘。

---

### 二、 不足 5 年怎么办？（数据降级策略）

对于那些上市不足 5 年的“次新”ETF（如某些中证 2000 ETF 或科创芯片 ETF），我们不能强行用 5 年。

我们需要一套 **“数据降级流程 (Fallback Strategy)”**：

1. **Level A（成熟标的）：上市时间 ≥ 5 年**
* **策略**：严格使用 **过去 5 年滚动窗口**。
* *注意*：是“滚动”的。计算今天的分位数，用的是 `今天往前推 5 年` 的数据；计算去年的分位数，用的是 `去年往前推 5 年` 的数据。


2. **Level B（青壮年标的）：3 年 ≤ 上市时间 < 5 年**
* **策略**：使用 **“上市至今的所有数据”**。
* *逻辑*：3 年虽然勉强，但已经积累了一定的波动样本，凑合能用。


3. **Level C（幼年标的）：上市时间 < 3 年**
* **策略**：**禁止使用自身的 PE 分位数**。数据样本太小，全是噪音，此时的“历史最低”和“历史最高”没有参考价值。
* **替代方案 1（锚定指数）**：使用其跟踪指数（Index）的估值数据。ETF 虽然刚上市，但指数可能已经存在 10 年了。
* **替代方案 2（同类映射）**：如果拿不到指数数据，直接使用 **“通用硬约束”**。
* 下限 = 上市以来最低价  0.9
* 上限 = 上市以来最高价  0.9 (防止新股炒作泡沫)





---

### 三、 Python 代码实现：智能窗口选择器

这段代码会自动帮你判断应该截取多长的数据。

```python
import pandas as pd
import numpy as np

def get_valuation_window(df, min_years=3, max_years=5):
    """
    智能截取估值计算的时间窗口
    :param df: 包含 'date' 和 'pe'/'price' 的完整历史数据
    :param min_years: 最小有效年限 (低于此认为数据不可靠)
    :param max_years: 目标标准年限 (通常为 5)
    :return: 截取后的 DataFrame (用于计算百分位)
    """
    if df.empty:
        return None
        
    # 1. 计算数据总时长 (天)
    total_days = (df['date'].iloc[-1] - df['date'].iloc[0]).days
    total_years = total_days / 365.25
    
    print(f"数据总时长: {total_years:.2f} 年")

    # 2. 决策逻辑
    if total_years >= max_years:
        # 情况 A: 数据充足 -> 截取最近 5 年
        # 250 交易日 * 5 = 1250 行
        cutoff_rows = int(250 * max_years)
        valid_df = df.iloc[-cutoff_rows:]
        print(f"✅ 采用标准策略: 截取最近 {max_years} 年数据")
        return valid_df
        
    elif total_years >= min_years:
        # 情况 B: 数据尚可 -> 使用全部历史
        print(f"⚠️ 数据不足 {max_years} 年: 使用上市至今全部数据")
        return df
        
    else:
        # 情况 C: 数据太少 -> 报警
        print(f"❌ 数据不足 {min_years} 年: 样本失效，建议使用指数数据或固定比例")
        # 这里你可以选择返回 None，或者返回全部数据但标记为“高风险”
        return df # 暂时返回全部，但在外部逻辑要做降权处理

# --- 核心计算逻辑 ---
def calculate_dynamic_limits_v2(full_history_df):
    # 1. 获取有效的时间窗口数据
    window_df = get_valuation_window(full_history_df, max_years=5)
    
    current_pe = full_history_df['pe'].iloc[-1]
    
    # 2. 在这个窗口内计算百分位
    # 注意：千万不要在全量历史里算，要在 window_df 里算
    pe_10_percentile = np.percentile(window_df['pe'], 10)
    pe_80_percentile = np.percentile(window_df['pe'], 80)
    
    # 3. 计算价格
    # Limit = Current_Price * (Target_PE / Current_PE)
    # ... (后续计算同前文)

```

### 四、 香农的补充建议

1. **不要用 10 年**：除非你做的是标普 500 这种百岁老人。A 股的许多行业（如新能源、互联网）10 年前的逻辑和现在是两个物种。**坚守 5 年线**。
2. **ETF 刚上市怎么办？**：如果你的代码检测到 `total_years < 3`，请在 UI 上弹出一个 **“黄灯警告”**，提示用户：“该标的上市时间过短，估值百分位可能失真，建议手动设置上下限或参考跟踪指数。”
3. **滚动窗口的重要性**：请确保你的回测系统在跑 2023 年的数据时，只看到了 2018-2023 年的历史，而**看不见** 2024 年的数据。这就是“滚动”的意义——防止**未来函数**泄露。