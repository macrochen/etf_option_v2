# 产品需求文档：异构投资组合跟投系统 (PRD V5.0)

**项目名称**：HPC-System (Heterogeneous Portfolio Copy-Trading)
**文档类型**：功能规格说明书
**核心变更**：新增“双模初始化机制”（爬虫优先，人工降级），明确 1:N 映射与事件驱动调仓闭环。

---

## 1. 产品逻辑综述

本系统旨在解决“无法实时、同构复制外部投资组合”的痛点。通过维护一个“目标虚拟账户”作为基准，将外部的**调仓行为（事件）翻译为本地账户的交易指令**。

### 核心工作流

1. **初始化**：通过爬虫或 Markdown 导入，建立目标组合的“虚拟持仓基准”。
2. **配置**：建立目标资产与本地资产的映射关系（支持 1对1、1对多）。
3. **监听**：输入调仓流水（如“买入 2.88元”）。
4. **翻译**：计算变动比例 -> 应用映射规则 -> 生成本地指令。
5. **闭环**：确认执行后，同步更新“虚拟持仓基准”，为下一次计算做准备。

---

## 2. 数据库设计 (Schema)

这是系统开发的基石。请在您的数据库中建立以下核心表结构。

### 2.1 虚拟账户基准表 (`virtual_target_positions`)

用于记录目标组合当前的持仓状态（分母），不需要每日更新净值，但必须在每次调仓后更新份额。

```sql
CREATE TABLE virtual_target_positions (
    target_code VARCHAR(20) PRIMARY KEY, -- 目标基金代码/名称
    target_name VARCHAR(100),
    
    base_shares DECIMAL(18, 4),    -- 【核心】当前持有的虚拟份额（计算分母）
    latest_nav DECIMAL(10, 4),     -- 最近一次录入的净值（用于金额转份额）
    
    source_type VARCHAR(10),       -- 'CRAWLER' (爬虫) or 'MANUAL' (人工)
    updated_at DATETIME            -- 最后一次变更时间
);

```

### 2.2 资产映射规则表 (`asset_mappings`)

支持 1对N 的核心配置。

```sql
CREATE TABLE asset_mappings (
    id INT PRIMARY KEY AUTO_INCREMENT,
    target_code VARCHAR(20),       -- 关联 virtual_target_positions
    
    local_code VARCHAR(20),        -- 本地代码 (如 510500)
    local_type VARCHAR(10),        -- 'ETF', 'OTC', 'STOCK'
    allocation_ratio DECIMAL(5,4) DEFAULT 1.0, -- 分配比例 (如 0.5 代表承接 50% 的变动)
    
    is_active BOOLEAN DEFAULT 1
);

```

---

## 3. 功能模块 I：系统初始化 (Initialization)

**入口**：UI 界面上的“新建跟踪/重置跟踪”按钮。
**逻辑**：采用“漏斗式”策略。

### 3.1 策略 A：爬虫自动抓取 (Primary)

* **输入**：目标组合的主页 URL。
* **交互**：用户点击“一键抓取”。
* **后台逻辑**：
1. 调用 Playwright/Selenium 访问 URL。
2. 等待表格 DOM 渲染。
3. 提取 `基金名称`, `代码`, `持有份额` (或持有金额+净值)。


* **异常处理**：若抓取失败（反爬、超时、格式变更），UI 弹窗提示红色警告：“自动抓取失败，请使用下方文本框手动导入”，并自动展开策略 B 的界面。

### 3.2 策略 B：Markdown 数据导入 (Fallback)

* **输入**：一个大的文本输入框。
* **交互**：用户将 AI 解析截图生成的 Markdown 表格粘贴于此。
* **数据清洗逻辑**：
* **归一化**：系统只认**“份额”**。
* 如果输入数据只有“持有金额”和“净值”，则自动计算：`份额 = 金额 / 净值`。
* 如果缺少净值，允许用户留空，但系统需标记该记录，后续通过 API (如 AkShare) 补全。



**输出结果**：无论 A 还是 B，最终都将清洗后的数据写入 `virtual_target_positions` 表，完成初始化。

---

## 4. 功能模块 II：映射配置 (Mapping Config)

初始化完成后，系统自动跳转至此页面。

### 4.1 界面布局

* **左侧（目标端）**：列出刚刚入库的所有目标基金（如：南方中证500联接）。
* **右侧（本地端）**：显示当前的映射关系。

### 4.2 关键交互：1对多拆分

假设目标是“中证500”，用户希望拆分为“华夏500”和“天弘500”。

1. 用户点击右侧的 **[拆分]** 按钮。
2. 该行分裂为两行子项。
3. **子项 1**：输入 `51xxxx (华夏)`, 类型 `ETF`, 比例 `0.5`。
4. **子项 2**：输入 `00xxxx (天弘)`, 类型 `OTC`, 比例 `0.5`。
5. **校验**：前端强制检查同一 Target 下的所有 `Ratio` 之和必须等于 1.0（允许用户手动确认为非 1.0，但需弹出风险提示）。

---

## 5. 功能模块 III：调仓指令引擎 (Rebalance Engine)

这是日常使用最高频的模块，基于**事件驱动**。

### 5.1 步骤 1：输入调仓流水

**场景**：你收到了主理人的调仓通知截图。
**交互**：

1. 粘贴 Markdown 表格（包含：标的名称、方向、金额/份额）。
2. **示例数据**：
* 买入 `鹏华安盈宝` 2.88 元。
* 卖出 `500联接` 1.25 份。



### 5.2 步骤 2：计算引擎 (核心算法)

系统后台执行以下逻辑：

**A. 预处理**

* 查询 `virtual_target_positions` 表，获取 `base_shares` (分母)。

**B. 变动率计算 (Change Ratio)**

* **Case 1 (按份额卖出)**:
`Ratio = -(卖出份额 1.25) / (基准份额 1000) = -0.125%`
* **Case 2 (按金额买入)**:
`预估份额 = 买入金额 2.88 / 最新净值 1.05`
`Ratio = +(预估份额) / (基准份额 2000) = +0.13%`

**C. 映射应用**

* 遍历该目标对应的所有映射规则。
* `本地操作量 = 用户总资产 * Ratio * Allocation_Ratio`。

### 5.3 步骤 3：输出指令与确认

**界面显示**：

* **[卖出]** 华夏500ETF: 建议卖出 **XX 股** (源自目标减仓 500联接)。
* **[卖出]** 天弘500增强: 建议赎回 **XX 元**。
* **[买入]** 银华日利ETF: 建议买入 **XX 股**。

**关键闭环操作**：
界面底部必须有一个 **[确认已执行]** 按钮。

* **点击后果**：系统将本次调仓的变动，更新回 `virtual_target_positions` 表。
* `New_Base_Shares = Old_Base_Shares + Transaction_Shares`。
* **意义**：确保下一次调仓时，分母是正确的，防止比例失真。

---

## 6. 异常边界处理

1. **新建仓 (New Position)**
* 如果调仓流水中出现了一个 `virtual_target_positions` 里不存在的代码。
* **系统行为**：暂停计算，弹窗提示“检测到新资产”。
* **用户操作**：手动输入该新资产在目标组合中的**预估初始权重**（如 5%），或手动指定买入金额。随后进入映射配置流程。


2. **微小份额变动**
* 如果计算出的 ETF 变动量为 5 股（不足 100 股）。
* **UI 表现**：显示为灰色，默认不勾选。备注：“不足一手，建议忽略”。


3. **爬虫失效**
* 这是大概率事件。
* **对策**：Markdown 导入功能必须作为**一等公民**设计，入口要明显，解析要鲁棒（Robust），容忍多余的列或空格。



---

## 7. 验收标准 (Acceptance Criteria)

为确保开发符合预期，请按以下标准验收：

1. **初始化测试**：粘贴一段 Markdown 持仓数据，系统能成功生成虚拟账户基准数据。
2. **映射测试**：配置一条 1:2 的映射（50%/50%），输入一笔目标减仓指令，生成的本地指令应包含两笔卖出，且金额各占一半。
3. **闭环测试**：执行一次“买入”指令后，查看数据库，`virtual_target_positions` 中该标的的 `base_shares` 应该增加了对应数值。如果不增加，下一次卖出的比例计算就会出错。