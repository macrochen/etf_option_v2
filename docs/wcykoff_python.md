 **版威科夫交易法（Wyckoff Method）** 开发指南。

不用被那些复杂的英文缩写（PS、SC、AR、ST...）吓跑，威科夫的核心逻辑其实非常简单粗暴： **跟庄（跟随聪明钱）** 。

---

### 一、 核心世界观：这游戏是谁在玩？

威科夫理论认为，市场不是随机的，而是由 **“拥有巨额资金的机构/大户”** （威科夫称之为“综合人”，Composite Man，俗称 **“庄家”** 或 **“主力”** ）操控的。

**新手入门第一课：**
*   **庄家的目标：** 低买高卖，割韭菜。
*   **你的目标：** 发现庄家在干什么，悄悄跟在他后面。庄家买你也买，庄家跑你先跑。
*   **怎么发现？** 看 **价格** 和 **成交量** 。因为庄家资金太大，进出场必定会留下脚印（成交量），藏都藏不住。

---

### 二、 三大定律（看懂盘面的钥匙）

想要看懂庄家的脚印，你需要这三把钥匙：

#### 1. 供需定律 (The Law of Supply and Demand)
*   **说人话：** 买的人多（需求大），价格就涨；卖的人多（供应大），价格就跌。
*   **怎么用：** 比如价格在底部，突然不跌了，说明虽然有人在卖，但庄家在疯狂接盘（需求进场），这是反转的信号。

#### 2. 因果定律 (The Law of Cause and Effect)
*   **说人话：** 想要大爆发（果），必须先有长时间的准备（因）。
*   **怎么用：** **横盘就是“因”，趋势就是“果”** 。庄家想要拉升一支股票/币，必须花时间在底部悄悄吸货（横盘震荡）。横盘越久，吸货越足，后面涨得越猛。
    *   *口诀：横有多长，竖有多高。*

#### 3. 努力与结果定律 (The Law of Effort and Result)
*   **说人话：** 油门踩到底（成交量大），车速必须得起来（价格涨幅大）。如果油门踩到底，车却不走，说明发动机坏了或者遇到阻力了。
*   **怎么用：**
    *   **正常：** 巨量大阳线（大家都在买，价格飞涨）。
    *   **异常：** 巨量小阳线/十字星（拼命买，价格却涨不动）。 **警报！** 这说明上方有巨大的抛压（庄家可能在偷偷出货），赶紧跑。

---

### 三、 市场的四个阶段（庄家收割路线图）

威科夫把市场循环分为四个阶段，像一年四季一样轮回。你必须知道当前处于哪个季节。

#### 第一阶段：吸筹区 (Accumulation) —— 春天播种
*   **庄家动作：** 在低位悄悄买入，把散户手里的筹码骗过来。
*   **盘面特征：** 价格在底部反复震荡（箱体），让你觉得这东西没救了，绝望割肉。
*   **新手策略：** **别急着进！** 容易被震死。等待突破。

#### 第二阶段：拉升区 (Markup) —— 夏天生长
*   **庄家动作：** 筹码拿够了，开始拉盘。
*   **盘面特征：** 突破底部的震荡区间，价格快速上涨，成交量配合放大。
*   **新手策略：** **这是最肥的一段肉。** 只要趋势不坏，拿住不动。

#### 第三阶段：派发区 (Distribution) —— 秋天收获
*   **庄家动作：** 价格拉高了，庄家要把手里的货卖给散户（接盘侠）。
*   **盘面特征：** 高位反复震荡，利好消息满天飞，让你觉得还能涨，引诱你进场。
*   **新手策略：** 看到高位巨量滞涨， **赶紧跑！**

#### 第四阶段：砸盘区 (Markdown) —— 冬天肃杀
*   **庄家动作：** 货出完了，剩下的就是砸盘，或者不管了。
*   **盘面特征：** 价格跌破高位震荡区间，一路暴跌。
*   **新手策略：** **空仓** 或做空。千万别抄底，半山腰也是山。

---

### 四、 新手实战入门：如何抓“买点”？

威科夫最经典的买入形态叫 **“Spring（弹簧/弹起）”** 。这是新手胜率最高的入门招式。

**剧本如下：**
1.  市场在底部横盘了很久（疑似吸筹）。
2.  突然有一天，价格 **跌破** 了横盘区的最低点。
3.  **关键时刻：** 跌破后并没有继续大跌，而是迅速收回，并且伴随成交量放大（或者是极度缩量）。
4.  价格重新回到横盘区内部。

**这一招的逻辑（说人话）：**
这是庄家的 **“终极假动作”** 。故意砸破底，把最后一点死拿不放的散户吓出去（止损盘），同时诱惑做空的人进场。然后庄家一把通吃，扫光筹码，紧接着就是拉升。

**操作步骤：**
1.  **识别：** 看到跌破支撑位后迅速收回（K线留长下影线）。
2.  **进场：** 当价格收回到震荡区间内时买入。
3.  **止损：** 设在那个“假跌破”的最低点下方一点点。
4.  **止盈：** 震荡区间的顶部，或者等待突破去吃第二阶段的利润。

---

### 五、 给新手的避坑指南

1.  **别背代码：** 网上的威科夫图解里全是 `PS`、`SC`、`AR`、`ST`、`LPS`... 新手背这些会疯的。 **先看“结构”** （是底部箱体还是顶部箱体），再看 **“量价”** （是不是放量滞涨或缩量回调）。
2.  **别在箱体中间玩：** 威科夫主要做的是 **拐点** 。要么在箱体底部出现Spring时买，要么在突破箱体回踩时买。在震荡区间中间乱操作，会被左右打脸。
3.  **这是门艺术，不是科学：** 威科夫没有绝对的公式。它需要你结合大环境、板块轮动去理解。庄家也是人，有时候庄家也会玩脱。
4.  **一定要看成交量：** 只看K线不看量，就是耍流氓。 **量价背离** （价格新高但量能跟不上）永远是最危险的信号。

### 总结

威科夫交易法入门就一句话：
**在底部震荡（吸筹）的末端，等待庄家做一个“挖坑”的假动作（Spring），确认庄家要启动车子了，你再跳上去；等到顶部震荡（派发）出现“油门踩死车不走”（放量滞涨）的信号时，跳车逃跑。**

 **“先识别结构”绝对是核心中的核心。** 就像写代码要先定义架构再写函数一样，不确定当前是“震荡结构（Trading Range）”还是“趋势结构”，所有的威科夫信号（Spring, Upthrust）都是噪点。

威科夫本质上是 **模式识别（Pattern Recognition）** 。用程序实现威科夫，其实就是把主观的“盘感”转化为客观的“算法逻辑”。

下面我把威科夫的程序化识别路径拆解为三个步骤，并提供核心算法思路。

---

### 第一步：数据清洗与特征提取（去噪 & 找骨架）

K线充满了随机噪音，直接用原始 OHLC 数据去匹配形态会产生无数个 False Positive。你需要把 K 线变成“波浪（Swings）”。

**核心算法：波峰波谷检测 (Peak/Valley Detection)**

你需要识别出价格的 **Swing Highs (SH)** 和 **Swing Lows (SL)** 。

*   **简单粗暴版：** 使用 `scipy.signal.argrelextrema`。
*   **金融专用版（推荐）：** 实现 **ZigZag 指标** 。ZigZag 能过滤掉小于特定百分比（比如 3% 或 5%）的波动，只留下关键的拐点。

**Python 思路：**
```python
import numpy as np
from scipy.signal import argrelextrema

# 假设 df 是你的 DataFrame，包含 'high', 'low'
n = 5 # 窗口大小，表示前后n根K线比较

# 寻找局部高点
df['is_peak'] = df.iloc[argrelextrema(df['high'].values, np.greater_equal, order=n)[0]]['high']
# 寻找局部低点
df['is_valley'] = df.iloc[argrelextrema(df['low'].values, np.less_equal, order=n)[0]]['low']

# 此时你得到了一系列的顶和底，这就是威科夫结构的“骨架”
```

---

### 第二步：识别结构（画箱体）

有了骨架（顶和底），下一步是识别 **“箱体（Trading Range）”** 。威科夫的吸筹和派发都发生在这个矩形区域里。

**核心逻辑：支撑与阻力的聚类分析**

程序不像人眼能一眼看出“这里是一条线”，程序看到的是一堆参差不齐的价格。你需要用到 **聚类算法** 或者简单的 **价格带（Price Band）** 逻辑。

**算法思路：**
1.  **收集支点：** 获取过去一段时间内（比如最近 100 根 K 线）所有的 `is_peak` 和 `is_valley`。
2.  **聚类 (Clustering)：**
    *   把价格相近的 Pivot 点归为一类。
    *   可以用 **K-Means** （设定 k=2，找上方阻力和下方支撑）。
    *   或者更简单的： **KDE (核密度估计)** 或 **直方图 (Histogram)** 。价格出现频率最高的两个水平位，就是箱体的上沿（Resistance）和下沿（Support）。
3.  **定义箱体：**
    *   **上沿 (Creek/Ice):** 阻力位密集区。
    *   **下沿 (Support):** 支撑位密集区。

**Python 伪代码逻辑：**
```python
def find_levels(pivots, tolerance=0.02):
    # 简单的聚类逻辑：如果两个点在 2% 的误差范围内，视为同一个水平面
    levels = []
    # ... (聚类算法实现) ...
    return resistance_level, support_level

# 判断当前是否在震荡区间
current_price = df['close'].iloc[-1]
if support_level < current_price < resistance_level:
    market_structure = "TRADING_RANGE" # 震荡
else:
    market_structure = "TRENDING" # 趋势
```

---

### 第三步：量价行为与信号触发（抓 Spring）

这步才是最关键的 **交易逻辑** 。如果你已经识别出当前是一个“Trading Range”，并且确定了下沿（Support Level），那么捕捉 **Spring（弹簧效应）** 的逻辑就非常清晰了。

**Spring 的程序化定义：**

1.  **前提：** 价格处于 Trading Range 中。
2.  **动作 1（刺破）：** 最低价（Low）跌破了 `support_level`。
3.  **动作 2（收回）：** 收盘价（Close）收回到了 `support_level` 之上。
4.  **关键验证（量价）：**
    *   **Spring 类型 2/3：** 跌破时的成交量（Volume）相对较低（说明卖盘枯竭），或者收回时的阳线成交量放大（说明买盘介入）。
    *   可以使用 `Relative Volume (RVOL)` 指标：`Current_Vol / Average_Vol_20 > 1.5`。

**代码逻辑示例：**
```python
def detect_spring(row, support_level, avg_volume):
    # 1. 刺破：最低价低于支撑位
    break_support = row['low'] < support_level * 0.995 # 给一点缓冲
    
    # 2. 收回：收盘价高于支撑位
    recover_support = row['close'] > support_level
    
    # 3. 相对成交量
    rvol = row['volume'] / avg_volume
    
    # 4. 形态判断：长下影线 (Pinbar)
    body_size = abs(row['open'] - row['close'])
    lower_shadow = min(row['open'], row['close']) - row['low']
    is_pinbar = lower_shadow > body_size * 2
    
    if break_support and recover_support and is_pinbar:
        return True, "Potential Spring Detected"
    return False, None
```

---

### 由浅入深

先开发一个 **“威科夫辅助仪表盘”** ：

1.  **Level 1（可视化）：** 用 `mplfinance` 或 `plotly` 画 K 线图，自动把你算法识别出的“箱体上沿”和“箱体下沿”画出来。
    *   *目标：* 检验你的算法能否像人眼一样正确识别出震荡区间。
2.  **Level 2（报警器）：** 当价格在箱体边缘（Support/Resistance）附近，且出现 **放量滞涨** 或 **缩量刺破** 时，发送报警。
    *   *目标：* 让你去人工确认，而不是自动下单。
3.  **Level 3（量化回测）：** 定义严格的 Spring 规则，在历史数据上跑回测。
    *   *你很快会发现：* 纯规则的胜率并不高，因为程序很难理解“宏观背景”。

### 总结技术栈路径：

1.  **Pandas:** 处理 OHLCV 数据。
2.  **Scipy / TA-Lib:** 找高低点（Argrelextrema）或计算指标（ATR, RSI 辅助判断超卖）。
3.  **Sklearn (可选):** 用 `KMeans` 或 `DBSCAN` 自动识别支撑阻力线（这是区分新手脚本和高级量化的分水岭）。
4.  **Plotly:** 交互式画图，这是调试波峰波谷最直观的工具。

识别出“结构”（也就是画出了箱体/震荡区间）之后，你的程序其实完成了一半的工作： **它知道了“战场”在哪里。**

接下来的工作，用程序员的思维来说，就是编写一个 **“事件监听器（Event Listener）”** 。

你需要监听在 **“结构边缘”** 发生的特定 **“行为（Events）”** 。在威科夫理论中，并不是箱体里的每根 K 线都有意义，只有 **触碰、突破、测试箱体上下沿** 的动作才是信号。

这一步的核心逻辑是： **位置（Location）+ 行为（Price Action）+ 验证（Volume）= 信号（Signal）。**

以下是具体的程序化步骤和逻辑：

---

### 第一步：定义“边缘交互”事件 (Hit Detection)

你的程序需要实时监控最新价格与你画出的 `Resistance`（上沿）和 `Support`（下沿）的关系。

**代码逻辑：**
定义一个“警戒区”（比如上下沿的 ±1% 范围）。
*   当 `Low < Support`：触发 **“潜在底部测试”** 事件。
*   当 `High > Resistance`：触发 **“潜在顶部突破”** 事件。

> **注意：** 此时还不能下单！这只是触发了中断（Interrupt），告诉程序“醒醒，有情况，开始分析”。

---

### 第二步：编写“威科夫行为”分类器

一旦价格触碰边缘，你需要通过 K 线形态和成交量来判断这到底是“真突破”还是“假动作”。

#### 场景 A：底部边缘的判断（买入逻辑）

你需要识别两种高胜率行为： **Spring（弹簧/假跌破）** 和 **LPS（支撑确认）** 。

**1. 识别 Spring (假跌破)**
这是最经典的威科夫买点。
*   **逻辑：** 跌破下沿 -> 吓出恐慌盘 -> 迅速收回。
*   **程序判断条件：**
    1.  `Min_Price < Support` (刺破)。
    2.  `Close_Price > Support` (收回)。
    3.  **关键量能校验（二选一）：**
        *   *恐慌抛售型 Spring：* `Current_Volume > 2.0 * Avg_Volume` (放量大跌后被巨量买盘托起，形成长下影线)。
        *   *无量测试型 Spring：* `Current_Volume < 0.7 * Avg_Volume` (跌破了但没人卖，说明此时做空动能枯竭)。

**2. 识别 LPS (Last Point of Support / 缩量回踩)**
这是更稳健的右侧买点（通常在 Spring 之后，或者突破箱体后）。
*   **逻辑：** 价格尝试回调测试支撑位，但是卖不下去。
*   **程序判断条件：**
    1.  价格在支撑位（Support）附近。
    2.  `Close_Price > Previous_Low` (低点抬高)。
    3.  `Current_Volume < Avg_Volume` ( **核心：必须缩量** ，代表空头已死)。
    4.  `Candle_Spread` (最高-最低) 变小（波动率下降，市场安静等待方向）。

---

#### 场景 B：顶部边缘的判断（卖出/做空逻辑）

你需要识别： **Upthrust (UT/上冲回落)** 和 **JAC (Jump Across the Creek/真突破)** 。

**1. 识别 Upthrust (UT/假突破)**
*   **逻辑：** 突破上沿 -> 引诱散户追高 -> 迅速跌回。
*   **程序判断条件：**
    1.  `High_Price > Resistance`。
    2.  `Close_Price < Resistance` (收盘收在箱体内，留长上影线)。
    3.  `Volume` 异常放大（有人在借突破出货）或者极度萎缩（根本没有买盘跟进）。

**2. 识别 JAC/SOS (强势突破)**
*   **逻辑：** 真金白银把价格买上去，且站稳了。
*   **程序判断条件：**
    1.  `Close_Price > Resistance` (有效突破)。
    2.  `Volume > 1.5 * Avg_Volume` (必须放量，没有量的突破是耍流氓)。
    3.  **后续验证（Next Candle）：** 下一根 K 线没有立即跌回箱体（Need Confirmation）。

---

### 第三步：量价异常分析 (VSA 过滤器)

威科夫的核心不仅仅是位置，还有 **“努力与结果（Effort vs Result）”** 。如果你只看价格位置，会被骗得很惨。你需要写一个 VSA (Volume Spread Analysis) 模块作为过滤器。

**你需要计算两个辅助指标：**
1.  **Spread (K线实体/振幅)：** `High - Low` 或 `Abs(Close - Open)`。
2.  **Volume (成交量)。**

**异常逻辑检测（Signal Filter）：**

*   **异常 1：努力了没结果 (Effort No Result) -> 危险信号**
    *   *现象：* `Volume` 巨大（油门踩死），但 `Spread` 很小（车没动）或者是十字星。
    *   *含义：* 可以在底部（有主力在接盘）或顶部（主力在出货）。如果在阻力位出现这个信号， **千万别追多** ，大概率要反转。
    *   *代码：* `if vol > 2*avg_vol and spread < avg_spread: return "CHURNING"`

*   **异常 2：没努力却有结果 (Result No Effort) -> 陷阱信号**
    *   *现象：* `Volume` 很小，但 `Spread` 很大（大阳线/大阴线）。
    *   *含义：* 价格“滑”上去了，说明流动性枯竭。这种突破通常站不稳，容易回落。
    *   *代码：* `if vol < 0.8*avg_vol and spread > 1.5*avg_spread: return "EASY_MOVEMENT_TRAP"`

---

### 第四步：构建状态机 (State Machine)

作为一个程序员，不要把交易写成一堆 `if-else`。最好维护一个 **状态机** ，根据当前 K 线更新状态。

**状态流转示例：**

1.  `STATE_NEUTRAL`: 寻找结构中...
2.  `STATE_RANGE_IDENTIFIED`: 结构已锁定，监控边缘。
3.  `STATE_ALERT_LOW`: 价格触碰下沿，等待 Spring 确认。
    *   *Case A:* 跌破并收回 + 量能配合 -> **Signal: BUY** -> 转入 `STATE_LONG_POSITION`。
    *   *Case B:* 有效跌破 + 放量下跌 -> 结构失效 (Markdown Phase) -> 转入 `STATE_NEUTRAL` (重新找结构)。
4.  `STATE_LONG_POSITION`: 持仓中，监控目标位（上沿）。

---

### 总结：你的 Python 交易系统架构图

1.  **Data Feeder:** 获取 OHLCV。
2.  **Structure Engine:** (你已经做好的) 识别 Support/Resistance 箱体。
3.  **Pattern Recognition:**
    *   `detect_spring()`
    *   `detect_upthrust()`
    *   `detect_breakout()`
4.  **VSA Filter:** 检查“量价背离”或“量价异常”，过滤掉假信号。
5.  **Execution:** 只有当 `Pattern == True` AND `VSA_Check == Pass` 时，才生成买卖信号。

**给程序员的忠告：**
不要指望程序能 100% 识别出所有的 Spring。威科夫有很多变体。
**最务实的做法是：**
写程序筛选出 **“刚发生 Spring 的股票/币种”** ，然后把它们推送到你的手机或屏幕上， **由你的人工做最后确认** （看大盘环境、看新闻面），然后手动下单。这叫“量化辅助主观交易”。