我是克劳德·香农。

这一份 PRD（产品需求文档）不仅仅是功能的堆砌，而是为了在混乱的市场信息流中建立一个低熵的、有序的**盈利提取机器**。

鉴于你能处理 1 分钟级数据，我们就不需要做蒙特卡洛模拟了，直接上**全量历史数据回放**。这将是上帝视角的真实复盘。

---

# 需求文档：A 股 ETF 网格交易回测与分析系统 (Grid-X System)

| 文档版本 | V1.0 |
| --- | --- |
| **设计者** | Claude Shannon |
| **核心理念** | 波动率捕获、几何级数增长、鲁棒性优先 |
| **适用市场** | A 股 ETF（T+1 制度，无印花税，低佣金） |

---

## 1. 产品背景与目标

* **背景**：大多数网格策略死于参数过拟合和对极端行情的忽视。
* **目标**：
1. **验证性**：通过高精度（1min）回测，验证特定 ETF 在特定参数下的夏普比率是否优于“买入持有”。
2. **指导性**：通过“参数热力图”寻找参数的“鲁棒高原”，而非单一的最优解，指导实盘参数设置。



---

## 2. 核心逻辑设定（后端 Python）

### 2.1 账户与费率模型

这是系统的物理法则，必须严格硬编码。

* **交易费率**：
* 买入：`佣金 (max(5, amount * 0.00006))` —— **注意：如果不满 5 元按 5 元收，这会严重影响小资金回测，需确认券商是否免 5**。如果你的券商免 5，则公式为 `amount * 0.00006`。
* 卖出：`佣金` （无印花税）。


* **T+1 库存管理（核心难点）**：
* 系统需维护两个库存变量：`free_shares`（可用持仓）和 `frozen_shares`（当日买入冻结）。
* **规则**：当日 `frozen_shares` 不能卖出。收盘后，`frozen_shares` 转入 `free_shares`。



### 2.2 网格算法引擎

* **网格类型**：**等比数列 (Geometric Sequence)**。
* *拒绝等差网格，确保每一格的资金效率恒定。*


* **非对称设计（支持）**：
* `buy_gap` (买入间距)：默认 1.5%
* `sell_gap` (卖出利润)：默认 2.0% (吃低费率的红利)


* **触发机制**：
* 基于 `1min` 数据的 `Close` 价判断成交。
* *高阶修正*：如果 1 分钟内的 `Low` < 买单价 < `High`，视为成交。



---

## 3. 功能需求详情

### 3.1 模块一：数据输入与清洗

* **输入**：
* ETF 代码 (如 `512480`)
* 时间范围 (`Start_Date` ~ `End_Date`)
* 初始本金 (`Initial_Capital`)


* **数据预处理**：
* 导入 OHLCV (1min) 数据。
* **除权除息处理**：必须使用**前复权**数据，否则分红造成的缺口会误触发网格买入。



### 3.2 模块二：高精度回测引擎 (Backtest Engine)

这是系统的“大脑”。

* **输入参数**：
* 网格密度 (`Grid_Density`)：例如 1.5%
* 区间下限 (`Lower_Limit`)：例如 0.800
* 区间上限 (`Upper_Limit`)：例如 1.500
* 单格买入金额 (`Position_Per_Grid`) 或 首仓比例。


* **输出数据流**：
* 每日净值曲线 vs 标的涨跌幅曲线。
* 交易明细表（买/卖、价格、费用、是否触发 T+1 限制）。



### 3.3 模块三：参数热力图 (The Heatmap) —— **核心分析功能**

这是为了防止过拟合，寻找“高原”。

* **逻辑**：
* 遍历 `Grid_Density` (X轴)：从 0.5% 到 5.0%，步长 0.1%。
* 遍历 `Lower_Limit` (Y轴) 或 `Profit_Spread` (止盈溢价)。
* **Z 轴 (颜色)**：**夏普比率 (Sharpe Ratio)** 或 **总收益率**。


* **可视化需求**：
* 生成一张二维矩阵热力图。
* **颜色编码**：红色（亏损/低效） -> 黄色（平庸） -> 绿色（高效区）。
* *用户价值*：用户一眼就能看到哪一块区域是绿色的，从而选择该区域的中心值，而不是边缘值。



### 3.4 模块四：评估指标看板

不要只给我看赚了多少钱，我要看承担了多少风险。

* **绝对收益**：`Total_Return` (%)
* **风险收益比**：`Sharpe_Ratio` (年化收益 / 年化波动率)
* **最大回撤**：`Max_Drawdown` (%) —— **最关键指标**。
* **套牢时长**：`Max_Underwater_Days` (净值创新高所需最长天数)。
* **资金效率**：`Avg_Cash_Utilization` (平均仓位占比)。如果只有 10%，说明网格设置太保守，浪费了资金。

---

## 4. 前端交互界面 (UI/UX) 建议

### 4.1 布局逻辑

1. **左侧：控制台**
* ETF 选择器。
* 日期选择器。
* **策略滑块**：网格密度、止盈比例、底仓比例。


2. **右上：净值对比图**
* 双线图：蓝色线（网格策略净值），灰色线（买入持有净值）。
* *交互*：鼠标悬停显示当日仓位比例。


3. **右下：热力图与雷达图**
* 热力图展示参数敏感性。
* 雷达图对比：收益、回撤、胜率、频率、资金利用率。



---

## 5. 异常边界情况处理 (Edge Cases)

在编码时，你必须处理以下“黑天鹅”逻辑：

1. **穿仓保护**：如果价格跌破 `Lower_Limit`，程序是停止买入（装死），还是继续倍投？
* *PRD 规定*：默认停止买入，保留最后现金。


2. **卖飞处理**：如果价格突破 `Upper_Limit`，程序是清仓，还是保留底仓？
* *PRD 规定*：保留设定好的底仓（如 2000 股），其余网格部分清仓变现。


3. **资金不足**：当触发买入信号但现金不足时，记录为“错失的交易 (Missed Trade)”，并统计错失带来的潜在收益损失。

---

### 香农的开发建议

**Phase 1 (MVP)**:
先写 Python 脚本，不带 UI。输入 1min CSV，输出 CSV 格式的交易记录和最终收益。重点验证 **T+1 逻辑** 和 **佣金扣除** 是否准确。

**Phase 2 (Visualization)**:
加上前端图表。此时重点开发 **“热力图”** 功能。这才是你区分于市面上普通网格工具的杀手锏。

**Phase 3 (Optimization)**:
加入 MA250 均线过滤器。如果当前价格 < MA250，自动建议加密网格；如果 > MA250，自动建议放宽网格。

---