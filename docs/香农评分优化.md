我是香农。

你发现了一个非常关键的**“系统性偏差”**。你的直觉是正确的：**目前的评分逻辑在牛市初期或强趋势行情中完全失效，导致它把最好的标的（高波动上涨）判了死刑。**

看一眼你的截图 `image_a0f29c.png`（日线走势图）和 `image_a0f299.png`（31.9 分）。
这只证券 ETF 明显走出了一个剧烈的“N”字形，且近期波动巨大，这本该是网格交易的“盛宴”。但因为价格涨上来了，远离了 MA250，且处于近一年的高位，你的算法给了它“不及格”。

这是因为你的算法把 **“趋势（Trend）”** 误判为了 **“风险（Risk）”**。

我们需要在信息论的层面上做一个修正：**我们要捕捉的是叠加在“载波（趋势）”上的“调制波（波动）”，而不是因为载波向上走了，就认为信号质量差。**

以下是具体的诊断与 **V2.0 修正方案**。

---

### 问题诊断：为什么现在的逻辑失效了？

#### 1. 长期基因 (MA250 穿越) 的尺度错误

* **你的逻辑**：穿越 MA250 才叫震荡。
* **现实**：MA250 是年线，穿越一次往往意味着牛熊周期的转换。**8 次/100天** 的穿越频率对于 MA250 来说是不可能的（那是心电图，不是股价）。
* **后果**：在任何一段持续超过 3 个月的趋势（无论是牛还是熊）中，价格都不会穿越 MA250。于是这一项得分直接归零。
* **香农修正**：网格吃的是**周级别**或**月级别**的波动，不是年级别的。你需要检测的是**“中频震荡”**，而非“低频反转”。

#### 2. 中期安全 (1年 Rank) 的窗口短视

* **你的逻辑**：价格在过去 1 年的高位 = 危险。
* **现实**：A 股经历了 3 年熊市，现在刚从地坑里爬出来。虽然它在“过去 1 年”是高位（Rank 80%），但放在“过去 5 年”可能只是山脚下（Rank 20%）。
* **后果**：由于“锚定效应”太近，导致只要一涨，系统就喊停。
* **香农修正**：安全边际必须拉长历史视野。

---

### V2.0 修正方案：更鲁棒的香农评分算法

我建议对两个核心逻辑进行 **“参数降维”** 和 **“窗口扩张”**。

#### 修正一：长期基因 (Long-term Gene) —— 改用“MA20 缠绕率”

我们不再看由于趋势导致的 MA250 偏离，我们看它是否**“习惯性地”**回归短期均线。

* **新指标**：**MA20 (月线) 穿越频率**
* **逻辑**：MA20 是布林带的中轨。如果一个标的在过去 3 年里，频繁地上穿下穿 MA20，说明它是一个“多动症患者”，这正是网格需要的。
* **新算法**：
1. 检测窗口：依然是 **3 年 (750天)**。
2. 统计对象：收盘价穿越 **MA20** 的次数（而不是 MA250）。
3. **评分标准**：
* **满分 (100分)**：穿越频率 ≥ **15 次/100天** (平均 6-7 天穿一次，极度活跃)。
* **零分 (0分)**：穿越频率 ≤ **5 次/100天** (单边逼空或阴跌)。




* **为什么改这个？** 即使是在大牛市中（价格一直在 MA250 上方），价格也会频繁回调触碰 MA20。这样证券 ETF 的基因分就能从 0 分救回来。

#### 修正二：中期安全 (Mid-term Safety) —— 引入“历史大分位”

* **新指标**：**3年/5年 价格分位数 (Rolling Rank)**
* **逻辑**：不要只跟去年比，要跟历史比。
* **新算法**：
1. 检测窗口：扩大到 **3 年 (750天)** 或 **5 年 (1250天)**。
2. 如果数据不足 3 年，取全量历史数据。
3. 计算 Rank：


* **为什么改这个？** 对于刚起步的牛市，1 年 Rank 可能是 90%（甚至 100%），但 3 年 Rank 可能只有 30%。这能真实反映它的估值并没有泡沫化。

#### 修正三（新增补丁）：趋势豁免机制 (Trend Exemption)

如果一个标的正在走强趋势（导致 Rank 很高），我们不能简单判死刑，要看它的**波动率是否足以覆盖风险**。

* **逻辑**：如果 `ATR / Price` (日均波动率) > 2.5%（波动极大），即使 Rank 偏高，也可以给高分。因为对于网格来说，**波动即正义，位置是次要的**。

---

### 修正后的 Python 代码片段

请用这段逻辑替换你原来的 `ShannonGridScorer` 中的对应部分：

```python
    def calculate_score(self):
        """
        V2.0 修正版：适配牛市与强趋势
        """
        # ------------------------------------------------------
        # 1. 长期基因 (Long Term) - 改用 MA20 穿越
        # ------------------------------------------------------
        lookback_long = 750 # 3年
        if self.total_len > lookback_long:
            data_long_close = self.close[-lookback_long:]
        else:
            data_long_close = self.close
        
        # 【关键修改】使用 MA20 而非 MA250
        # MA20 更能反映“震荡”属性，MA250 反映的是“趋势”属性
        cross_freq = self._calc_ma_crossings(data_long_close, window=20) 
        
        # 评分标准调整：MA20 穿越非常频繁，阈值要提高
        # > 15次/100天 (平均每周穿一次) = 100分
        # < 5次/100天 (一个月都不穿一次) = 0分
        score_long = np.interp(cross_freq, [5, 15], [0, 100])
        
        # ------------------------------------------------------
        # 2. 中期安全 (Medium Term) - 扩大窗口至 3-5 年
        # ------------------------------------------------------
        lookback_mid = 1000 # 约 4 年，覆盖一个完整的牛熊周期
        if self.total_len > lookback_mid:
            data_mid = self.close[-lookback_mid:]
        else:
            data_mid = self.close # 数据不够就用全部
            
        current_price = self.close[-1]
        rank = self._calc_price_rank(current_price, data_mid)
        
        # 评分标准：Rank 越低分越高
        # 20% 分位以下满分，80% 分位以上零分
        score_mid = np.interp(rank, [20, 80], [100, 0])

        # ------------------------------------------------------
        # 3. 短期热度 (Short Term) - 保持不变
        # ------------------------------------------------------
        lookback_short = 60
        s_idx = -lookback_short
        recent_amp = self._calc_volatility_energy(self.high[s_idx:], self.low[s_idx:], self.close[s_idx:])
        # 日均振幅 > 2.5% 满分 (稍微提高标准，证券ETF通常波动很大)
        score_short = np.interp(recent_amp, [0.5, 2.5], [0, 100])

        # ------------------------------------------------------
        # 4. 加权汇总
        # ------------------------------------------------------
        total_score = (score_long * 0.4) + (score_mid * 0.3) + (score_short * 0.3)
        
        return {
            "total_score": round(total_score, 1),
            "details": {
                "long_term_gene": round(score_long, 1),   # 基因 (MA20缠绕度)
                "mid_term_safety": round(score_mid, 1),   # 安全 (历史大周期位置)
                "short_term_heat": round(score_short, 1)  # 热度 (近期波动)
            },
            "raw_metrics": {
                "cross_frequency_ma20": round(cross_freq, 2), # MA20 穿越率
                "price_rank_4y": round(rank, 2),              # 4年分位数
                "recent_amplitude": round(recent_amp, 2)
            }
        }

```

### 总结

你的逻辑没有根本错误，只是**“尺子”选错了**：

1. **MA250 太“粗”**：拿它量网格震荡，就像用卡车地磅称金戒指，显示重量为 0。**换成 MA20**。
2. **1年窗口 太“短”**：在刚走出熊市的时候，1年最高价不代表真的很贵。**换成 4 年**。

应用这个修正后，那只证券 ETF 的分数应该会大幅回升到 **70-80 分** 左右，这才是符合体感的结论。



你的“短期热度”逻辑目前是 **80 分**。它抓住了“波动”这个核心，但它的算法有一个**“结构性盲区”**和一个**“统计学陷阱”**。

在信息论中，我们不仅要看信号的**强度**（Amplitude），还要看信号的**完整性**（Completeness）和**稳定性**（Stability）。

以下是两个需要优化的地方，以及为什么这样改能让你的评分更精准。

---

### 优化一：从“日内振幅”升级为“真实波幅 (True Range)”

**问题所在：丢失了“跳空”信息 (The Gap Blind Spot)**

* **你的原公式**：`每日振幅 = (最高价 - 最低价) / 收盘价`
* **场景漏洞**：
* 假设昨天收盘 10.00 元。
* 今天因为利好，直接 **跳空高开** 在 10.50 元，全天在 10.50 - 10.60 之间窄幅震荡，收盘 10.55。
* **你的算法**：`(10.60 - 10.50) / 10.55 ≈ 0.9%`。 -> **低分（死鱼）**。
* **真实情况**：价格相对于昨天收盘涨了 5%！网格策略会因为这个巨大的跳空，瞬间卖出好几格筹码，产生大量利润。


* **香农视角的修正**：**跳空 (Gap)** 本身就是巨大的波动能量。你的算法只看了“开盘后的故事”，忽略了“隔夜的剧变”。

**优化方案：引入 ATR (Average True Range) 的核心思想**

不再只看当天的 High-Low，而是看 **“真实波幅 (TR)”**。

* **人话解释**：今天的波动，是“今天的最高最低差”，或者“今天最高和昨天收盘的差”，或者“今天最低和昨天收盘的差”，这三者里**最大**的那个。

---

### 优化二：从“算术平均”升级为“中位数/分位数”

**问题所在：被“极端值”欺骗 (The Outlier Trap)**

* **你的原公式**：`Sum(振幅) / 60`
* **场景漏洞**：
* 过去 60 天里，有 3 天发生了惊天动地的大崩盘（振幅 8%），其余 57 天都是 0.3% 的死鱼织布。
* **你的算法**：`(8%*3 + 0.3%*57) / 60 ≈ 0.7%`。分数被那 3 天强行拉高了。
* **真实体验**：你冲着 0.7% 的平均分进去了，结果发现实际上 95% 的时间里根本不成交。那 3 天的极端波动是不可持续的“噪音”。


* **香农视角的修正**：网格交易需要的是**“可持续的日常波动”**，而不是偶尔的诈尸。**中位数 (Median)** 比平均值更诚实。

**优化方案：使用 75% 分位数或中位数**

* 不要算平均值。
* 把过去 60 天的真实波幅 (TR) 从小到大排队。
* 取 **中位数 (50th Percentile)** 或者 **更保守一点的 40th Percentile**。
* **逻辑**：只有当“大部分日子”的波动都很大时，才给高分。

---

### V2.0 优化后的 Python 代码逻辑

请用以下逻辑替换你原来的 `_calc_volatility_energy` 函数：

```python
    def _calc_volatility_energy(self, high, low, close, pre_close):
        """
        V2.0 优化版：短期热度计算
        1. 使用 True Range (TR) 捕捉跳空缺口
        2. 使用 Median (中位数) 剔除极端值干扰
        """
        # 确保数据对齐，长度一致
        n = len(close)
        if n < 2: return 0
        
        tr_list = []
        # 从第二天开始计算 (因为需要昨收)
        for i in range(1, n):
            h = high[i]
            l = low[i]
            pc = pre_close[i-1] # 昨收
            c = close[i]
            
            # 核心修正：计算真实波幅 TR
            # 场景1: 盘中震荡 (H-L)
            # 场景2: 向上跳空 (H-PC)
            # 场景3: 向下跳空 (PC-L)
            tr = max(h - l, abs(h - pc), abs(l - pc))
            
            # 归一化为百分比
            tr_pct = tr / c * 100
            tr_list.append(tr_pct)
            
        # 核心修正：使用中位数 (Median) 代替平均值 (Mean)
        # 这能过滤掉偶尔几天的极端行情，反映“常态化”的波动水平
        median_tr = np.median(tr_list)
        
        return median_tr

```

### 为什么这么改？（总结）

1. **更贪婪**：原逻辑会漏掉“跳空高开/低开”带来的利润机会。改为 **TR (真实波幅)** 后，能把隔夜的波动也算进“热度”里，评分会更准。
2. **更诚实**：原逻辑会被几天的大暴跌拉高平均分。改为 **Median (中位数)** 后，只有当这个 ETF **天天**都上蹿下跳时，分数才会高。

**评分标准微调建议**：
由于 TR 包含了跳空，数值通常比单纯的日内振幅大一点。建议评分阈值保持不变（依然是 >2.0% 满分），这样相当于变相提高了一点点要求，筛选出真正的“热点”。