这是一个非常棒的工程化想法。作为一个威科夫初学者，试图完全“自动化”威科夫（Phase A-E 的精准划分）是非常困难且容易出错的，因为威科夫极其依赖**“语境” (Context)** [Villahermosa 348]。

但是，**写一个辅助决策系统（Copilot）是完全可行的**。我们可以利用 David Weis 在《即将发生的交易》中提到的**“行为逻辑”**（K线形态+量价）来识别关键点，并用 Python 帮你**“画线”**和**“报警”**。

基于你提供的茅台数据和威科夫理论书籍，我为你设计了一个 Python 系统的实现方案。这个系统不负责“预测未来”，而是负责**“识别现状”**和**“制定风控预案”**。

---

### 系统核心逻辑：威科夫“辅助决策”三步走

这个程序将实现三个功能模块：
1.  **识别战场（自动画箱体）**：基于 Villahermosa 的理论，识别支撑（Ice）和阻力（Creek）。
2.  **识别信号（自动找 Spring/UT）**：基于 Weis 的 K 线读图逻辑，寻找假突破。
3.  **风控预案（失败了怎么办）**：基于支撑/阻力位，自动计算止损点。

### Python 代码实现

你可以直接使用这份代码。它使用 `pandas` 处理数据，`mplfinance` 画图。

**前置准备**：
请将你的茅台数据整理为 `maotai.csv`，表头需要是：`Date,Open,High,Low,Close,Volume`。

```python
import pandas as pd
import numpy as np
import mplfinance as mpf

# ==========================================
# 1. 威科夫核心逻辑计算模块
# ==========================================

def identify_wyckoff_structure(df, window=30):
    """
    识别威科夫结构：箱体、Spring、Upthrust
    window: 滚动窗口，用于定义局部的“支撑”和“阻力”
    """
    # 1. 定义动态支撑 (Ice) 和 阻力 (Creek)
    # 逻辑：过去 N 天的最高/最低点作为临时的箱体边界
    df['Resistance'] = df['High'].rolling(window=window).max()
    df['Support'] = df['Low'].rolling(window=window).min()
    
    # 2. 计算均线 (辅助判断趋势)
    df['MA50'] = df['Close'].rolling(window=50).mean()
    df['MA200'] = df['Close'].rolling(window=200).mean()
    
    # 3. 识别 Spring (弹簧/挖坑) - 买入信号
    # 逻辑：最低价跌破了过去的支撑位，但收盘价收回去了
    # Weis 理论：这是一个陷阱，把弱手震出去 [Weis 289]
    df['Signal'] = np.nan
    df['Stop_Loss'] = np.nan # 风控：止损位
    
    # 遍历寻找信号 (从第50天开始)
    for i in range(50, len(df)):
        current_low = df['Low'].iloc[i]
        current_high = df['High'].iloc[i]
        current_close = df['Close'].iloc[i]
        prev_support = df['Support'].iloc[i-1] # 昨天的支撑线
        prev_resistance = df['Resistance'].iloc[i-1] # 昨天的阻力线
        
        # --- 识别 Spring (潜在买点) ---
        # 条件：(1) 最低价刺破支撑 (2) 收盘价站回支撑上方 (3) 处于相对低位或震荡区
        if (current_low < prev_support) and (current_close > prev_support):
            df.at[df.index[i], 'Signal'] = 'Spring (Buy)'
            # 【失败应对】：如果买入，止损放在 Spring 最低点下方一点点
            df.at[df.index[i], 'Stop_Loss'] = current_low * 0.99 

        # --- 识别 Upthrust (上冲回落/UT) - 潜在卖点/止盈点 ---
        # 条件：(1) 最高价突破阻力 (2) 收盘价跌回阻力下方
        # Weis 理论：突破失败，主力在派发 [Weis 297]
        elif (current_high > prev_resistance) and (current_close < prev_resistance):
            df.at[df.index[i], 'Signal'] = 'Upthrust (Sell)'
            # 【失败应对】：如果做空，止损放在 UT 最高点上方
            df.at[df.index[i], 'Stop_Loss'] = current_high * 1.01

    return df

# ==========================================
# 2. 绘图与可视化模块
# ==========================================

def plot_wyckoff_chart(df):
    # 截取最近数据以便观察 (比如最近 200 天)
    plot_df = df.iloc[-200:]
    
    # 设置标注点
    apd = []
    
    # 绘制支撑阻力带 (模拟箱体)
    apd.append(mpf.make_addplot(plot_df['Resistance'], color='red', linestyle='--', width=0.8))
    apd.append(mpf.make_addplot(plot_df['Support'], color='green', linestyle='--', width=0.8))
    
    # 绘制买卖信号
    # 提取 Spring 信号
    buy_signals = plot_df['Signal'].apply(lambda x: plot_df.loc[x.index, 'Low']*0.98 if x == 'Spring (Buy)' else np.nan)
    # 提取 UT 信号
    sell_signals = plot_df['Signal'].apply(lambda x: plot_df.loc[x.index, 'High']*1.02 if x == 'Upthrust (Sell)' else np.nan)

    # 标记信号点
    if not buy_signals.isna().all():
        apd.append(mpf.make_addplot(buy_signals, type='scatter', markersize=50, marker='^', color='g'))
    if not sell_signals.isna().all():
        apd.append(mpf.make_addplot(sell_signals, type='scatter', markersize=50, marker='v', color='r'))

    # 绘图设置
    # style = mpf.make_mpf_style(base_mpf_style='yahoo', rc={'font.family': 'SimHei'}) # 解决中文乱码
    
    print("正在生成威科夫分析图...")
    mpf.plot(plot_df, type='candle', style='yahoo', volume=True, 
             addplot=apd, 
             title='Wyckoff Helper: Spring & Upthrust Detection',
             ylabel='Price', ylabel_lower='Volume',
             figratio=(14, 8), tight_layout=True)

# ==========================================
# 3. 主程序入口 (假设数据已准备好)
# ==========================================
# 这里使用模拟数据加载，请替换为 pd.read_csv('你的文件路径.csv')
# df = pd.read_csv('maotai_data.csv', parse_dates=['Date'], index_col='Date')
# df = identify_wyckoff_structure(df)
# plot_wyckoff_chart(df)

# 输出最新的操作建议
def generate_trade_plan(df):
    latest_signal = df[df['Signal'].notna()].iloc[-1]
    print(f"--- 最新威科夫信号 ({latest_signal.name.date()}) ---")
    print(f"信号类型: {latest_signal['Signal']}")
    print(f"当前收盘: {latest_signal['Close']:.2f}")
    
    if 'Spring' in latest_signal['Signal']:
        print(f"【操作逻辑】: 价格刺破支撑位 {latest_signal['Support']:.2f} 后收回，可能是主力挖坑(Spring)。")
        print(f"【失败应对(止损)】: 如果未来价格跌破 {latest_signal['Stop_Loss']:.2f}，说明Spring失败，支撑无效，必须离场！")
    elif 'Upthrust' in latest_signal['Signal']:
        print(f"【操作逻辑】: 价格突破阻力位 {latest_signal['Resistance']:.2f} 后失败，可能是主力诱多(UT)。")
        print(f"【失败应对(止损)】: 如果未来价格站稳 {latest_signal['Stop_Loss']:.2f} 上方，说明是真突破(SOS)，空单离场或追多。")

# 注意：请先加载数据 df，然后运行:
# generate_trade_plan(df)
```

### 这个系统如何帮你做决策？（结合理论解读）

这个系统的设计完全基于你提供的资料中关于**“Spring”**和**“Upthrust”**的定义。

#### 1. 识别箱体（Creek 和 Ice）
*   **代码逻辑**：`df['Resistance']` 和 `df['Support']`。
*   **威科夫原理**：威科夫分析的第一步是找出价格在哪里震荡。代码通过滚动计算过去 N 天的最高/最低点，动态地画出 Villahermosa 书中提到的 **“Creek（小溪/阻力）”** 和 **“Ice（冰层/支撑）”** [Villahermosa 136, 143]。
*   **新手用法**：看图上的红虚线（阻力）和绿虚线（支撑）。价格在中间就是 Phase B（震荡），不要乱动。

#### 2. 识别买卖点（Spring 和 Upthrust）
*   **代码逻辑**：检测“刺破边界但收盘收回”的 K 线。
*   **威科夫原理**：
    *   **Spring (买点)**：David Weis 在书中花了整整一章讲这个。代码捕捉的是：价格跌破了绿线（Support），但是收盘价又站回了绿线之上。这代表**“空头陷阱”**，主力在低位接走了恐慌盘 [Weis 539]。
    *   **Upthrust (卖点)**：价格突破了红线（Resistance），但收盘价跌回红线之下。这代表**“多头陷阱”**，主力在利用突破诱多出货 [Weis 564]。
*   **新手用法**：看到图上出现绿色向上三角形（Spring），关注买入机会；看到红色向下三角形（Upthrust），警惕见顶。

#### 3. 失败了如何应对？（风控核心）
这是你最关心的问题。威科夫交易不是算命，是**“试错”**。

*   **代码逻辑**：`df['Stop_Loss']`。
*   **应对策略**：
    *   **Spring 失败**：程序会告诉你：“止损位是 Spring 的最低点”。
    *   **原理**：根据 Weis 的理论，Spring 的本质是测试。如果测试成功，价格应该立刻上涨（跳离跳板）。**如果价格买入后不涨，反而跌破了 Spring 的最低点**，说明这不是挖坑，而是真的暴跌（Sign of Weakness）[Weis 543]。
    *   **操作**：**无脑止损**。不要抱有幻想，因为根据理论，跌破 Spring 低点意味着支撑彻底失效。

### 给新手的建议

1.  **不要完全依赖自动信号**：运行程序后，看图。如果程序标注了 Spring，你去看看下面的**成交量**。如果是**缩量**回踩，成功率更高（Villahermosa 提到的 Test）[Villahermosa 272]。
2.  **大周期优先**：Weis 强调，月线和周线上的 Spring 威力最大 [Weis 553]。你可以把 csv 数据换成周线数据再运行一遍代码，看到的信号会更稳。
3.  **应对“打脸”**：如果程序提示 Spring（买入），你买进去了，结果第二天价格一根大阴线跌破了程序给出的止损价。**立刻卖出**。这就是系统提示的“失败应对”。威科夫交易员的生存法则就是：**在关键点位试错，错了就小亏离场，对了就拿住 Phase E 的大趋势**。